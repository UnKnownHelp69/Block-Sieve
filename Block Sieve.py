



max_sqrt = 100000 #корень из максимально допустимого n, можно считать после ввода n, но тогда надо уметь считать корень числа.
s = 2 #по сколько будет чисел в блоке, оптимальное - 10000, но для удобства понимания алгоритма я возьму 2
nprime = [False] * max_sqrt #заполняем массив, как при оригинальном решете, но значениями до корня из n
primes = [] #массив в котором будут лежат простые до корня
count = 0 #счетчик простых до корня

n = int(input())

i = 2
while i * i <= n: #считаем простые от 1 до sqrt(n)
    if not nprime[i]: #если простое
        primes.append(i) #в этом массиве лежат все простые до корня из n
        
        count += 1 #обновляем счетчик простых до корня из n
        
        if (i*i)*(i*i) <= n: #запускаем, если i <= sqrt(sqrt(n)) - мы как бы разбили задачу, и теперь как бы решаем задачу найти все простые от 1 до m и еще раз используем оптимизацию до корня
            j = i*i
            while j*j <= n:#здесь идет стандартное вычеркивание эратосфеном
                nprime[j] = True
                j+=i
    i+=1

result = 0  #заводим счетчик простых чисел

maxk = n//s #сколько у нас будет блоков

for k in range(maxk+1): #итерируемся по каждому блоку
    
    block = [False] * s #блок, в котором, пока все простое
    start = k * s #то, в каком месте(индексе) мы сейчас находимся, если собрать все блоки последовательно
    
    for i in range(count): #итерируемся по всем простым до корня из n
        
        start_idx = (start + primes[i] - 1) // primes[i] 
        j = max(start_idx, 2) * primes[i] - start #данные две строчки кода находят с какого положения надо начинать зачеркивать простые числа, то есть грубо говоря в блоке из [5, 6], при s = 2, мы вычеркнем именно 5. А max(start_idx, 2) обрабатывают первые итерации, чтобы простые числа, которые мы уже нашли, сами себя не вычеркнули.
        
        while j < s: #здесь уже идет стандартное вычеркивание эратосфеном
            block[j] = True
            j += primes[i]
            
    if k == 0: #в самой первой итерации убираем 0, 1
        block[0] = block[1] = True
    for i in range(s):
        if start+i <= n and not block[i]: #если мы не вышли за границы n(n не обязательно будет концом какого-то блока, может получиться, что блок будет заканчивать числом m+n) и число простое, то:
            result += 1 #увеличиваем счетчик простых на 1

print(result)





